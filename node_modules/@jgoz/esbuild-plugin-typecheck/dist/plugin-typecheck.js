"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js"(exports, module2) {
    var tty = require("tty");
    var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input;
      let index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let start = string.substring(0, index) + replace;
      let end = string.substring(index + close.length);
      let nextIndex = end.indexOf(close);
      return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
    };
    var createColors = (enabled = isColorSupported) => ({
      isColorSupported: enabled,
      reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
      bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
      dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
      italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
      underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
      inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
      hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
      strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
      black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
      red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
      green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
      yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
      blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
      magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
      cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
      white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
      gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
      bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
      bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
      bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
      bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
      bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
      bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
      bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
      bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
    });
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  TypecheckRunner: () => TypecheckRunner,
  typecheckPlugin: () => typecheckPlugin
});
module.exports = __toCommonJS(src_exports);

// src/typecheck-runner.ts
var import_path = __toESM(require("path"));
var import_picocolors = __toESM(require_picocolors());
var import_worker_threads = require("worker_threads");
var SUCCESS = process.platform === "win32" ? "\u221A" : "\u2714";
var WARNING = process.platform === "win32" ? "\u203C" : "\u26A0";
var ERROR = process.platform === "win32" ? "\xD7" : "\u2716";
var INFO = process.platform === "win32" ? "i" : "\u2139";
var DEFAULT_LOGGER = {
  info(message) {
    console.info(import_picocolors.default.bold(INFO) + "  " + message);
  },
  warn(message) {
    console.warn(import_picocolors.default.bold(import_picocolors.default.yellow(WARNING)) + "  " + message);
  },
  error(message) {
    console.error(import_picocolors.default.bold(import_picocolors.default.red(ERROR)) + "  " + message);
  },
  success(message) {
    console.info(import_picocolors.default.bold(SUCCESS) + "  " + import_picocolors.default.green(message));
  }
};
var BUILD_MSG = { type: "build" };
var notify = () => {
};
try {
  notify = require("@jgoz/esbuild-plugin-livereload").notify;
} catch {
}
var TypecheckRunner = class {
  constructor({
    absWorkingDir: basedir,
    logger = DEFAULT_LOGGER,
    omitStartLog,
    watch,
    ...options
  }) {
    const inputConfigFile = options.configFile;
    const configFile = inputConfigFile ? import_path.default.isAbsolute(inputConfigFile) ? inputConfigFile : import_path.default.resolve(basedir, inputConfigFile) : void 0;
    const workerData = {
      ...options,
      basedir,
      configFile,
      watch: !!watch
    };
    this.configPath = configFile ?? basedir;
    this.logger = logger;
    this.worker = new import_worker_threads.Worker(import_path.default.resolve(__dirname, "./typescript-worker.js"), { workerData });
    let errors = [];
    let warnings = [];
    let isBuilding;
    let isWatching;
    this.worker.on("message", (msg) => {
      switch (msg.type) {
        case "start": {
          errors = [];
          warnings = [];
          isBuilding ?? (isBuilding = msg.build);
          isWatching ?? (isWatching = msg.watch);
          if (!omitStartLog)
            logStarted(logger, { build: isBuilding, watch: isWatching });
          break;
        }
        case "summary":
        case "diagnostic": {
          errors.push(...msg.diagnostics.filter((d) => d.type === "error").map((d) => d.message));
          warnings.push(...msg.diagnostics.filter((d) => d.type === "warning").map((d) => d.message));
          console.error(import_picocolors.default.isColorSupported ? msg.output.pretty : msg.output.standard);
          break;
        }
        case "done": {
          notify("typecheck-plugin", { errors, warnings });
          if (msg.errorCount) {
            logFailed(
              logger,
              msg.errorCount === 1 ? "1 error" : `${msg.errorCount} errors`,
              msg.duration
            );
            process.exitCode = 1;
          } else {
            logPassed(logger, msg.duration);
            process.exitCode = 0;
          }
          break;
        }
        case "build":
          throw new Error("Unexpected message from worker: " + JSON.stringify(msg));
      }
    });
    this.worker.on("error", (e) => {
      console.error(e);
      process.exitCode = 1;
    });
    this.worker.on("exit", (code) => {
      if (code !== 0)
        process.exitCode = code;
    });
  }
  start() {
    this.worker.postMessage(BUILD_MSG);
  }
};
function logStarted(logger, { build = false, watch = false } = {}) {
  const opts = [build && "build", watch && "watch"].filter(Boolean).join(", ");
  const optStr = opts ? import_picocolors.default.cyan(` (${opts})`) : "";
  logger.info("Typecheck started\u2026" + optStr);
}
function logPassed(logger, duration) {
  logger.success("Typecheck passed");
  logger.info(import_picocolors.default.gray(`Typecheck finished in ${duration.toFixed(0)}ms`));
}
function logFailed(logger, numErrors, duration) {
  logger.error(`Typecheck failed with ${import_picocolors.default.bold(numErrors)}`);
  logger.info(import_picocolors.default.gray(`Typecheck finished in ${duration.toFixed(0)}ms`));
}

// src/typecheck-plugin.ts
function typecheckPlugin({
  configFile,
  watch: forceWatch,
  ...options
} = {}) {
  return {
    name: "typecheck-plugin",
    setup(build) {
      const { absWorkingDir = process.cwd(), tsconfig, watch } = build.initialOptions;
      const runner = new TypecheckRunner({
        ...options,
        absWorkingDir,
        configFile: configFile ?? tsconfig,
        watch: !!forceWatch || !!watch
      });
      build.onStart(() => {
        runner.start();
      });
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TypecheckRunner,
  typecheckPlugin
});
//# sourceMappingURL=plugin-typecheck.js.map
